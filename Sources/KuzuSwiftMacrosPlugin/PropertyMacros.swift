import SwiftCompilerPlugin
import SwiftSyntax
import SwiftSyntaxBuilder
import SwiftSyntaxMacros
import SwiftDiagnostics
import Foundation

public struct IDMacro: PeerMacro {
    public static func expansion(
        of node: AttributeSyntax,
        providingPeersOf declaration: some DeclSyntaxProtocol,
        in context: some MacroExpansionContext
    ) throws -> [DeclSyntax] {
        
        guard declaration.is(VariableDeclSyntax.self) else {
            let diagnostic = Diagnostic(
                node: declaration,
                message: PropertyMacroDiagnostic.mustBeAppliedToProperty
            )
            context.diagnose(diagnostic)
            return []
        }
        
        // Generate metadata comment
        return [
            """
            // MARK: - Primary Key Property
            // Generated by @ID macro
            // This property serves as the PRIMARY KEY for the node/edge table
            """
        ]
    }
}

public struct IndexMacro: PeerMacro {
    public static func expansion(
        of node: AttributeSyntax,
        providingPeersOf declaration: some DeclSyntaxProtocol,
        in context: some MacroExpansionContext
    ) throws -> [DeclSyntax] {
        
        guard declaration.is(VariableDeclSyntax.self) else {
            let diagnostic = Diagnostic(
                node: declaration,
                message: PropertyMacroDiagnostic.mustBeAppliedToProperty
            )
            context.diagnose(diagnostic)
            return []
        }
        
        // Generate metadata comment
        return [
            """
            // MARK: - Indexed Property
            // Generated by @Index macro
            // This property will have a database index for improved query performance
            """
        ]
    }
}

public struct VectorMacro: PeerMacro {
    public static func expansion(
        of node: AttributeSyntax,
        providingPeersOf declaration: some DeclSyntaxProtocol,
        in context: some MacroExpansionContext
    ) throws -> [DeclSyntax] {
        
        guard let variableDecl = declaration.as(VariableDeclSyntax.self) else {
            let diagnostic = Diagnostic(
                node: declaration,
                message: PropertyMacroDiagnostic.mustBeAppliedToProperty
            )
            context.diagnose(diagnostic)
            return []
        }
        
        // Validate Array<Double> or [Double] type
        guard let binding = variableDecl.bindings.first,
              let typeAnnotation = binding.typeAnnotation?.type else {
            return []
        }
        
        let typeString = typeAnnotation.description.trimmingCharacters(in: CharacterSet.whitespacesAndNewlines)
        let isValidType = typeString.contains("Array<Double>") || 
                         typeString.contains("[Double]") ||
                         typeString.contains("Array<Double>?") ||
                         typeString.contains("[Double]?")
        
        if !isValidType {
            let diagnostic = Diagnostic(
                node: typeAnnotation,
                message: PropertyMacroDiagnostic.vectorRequiresArray
            )
            context.diagnose(diagnostic)
            return []
        }
        
        // Validate dimensions parameter
        guard case .argumentList(let arguments) = node.arguments,
              let dimensionsArg = arguments.first(where: { $0.label?.text == "dimensions" }),
              let dimensionsExpr = dimensionsArg.expression.as(IntegerLiteralExprSyntax.self),
              let dimensions = Int(dimensionsExpr.literal.text),
              dimensions > 0 else {
            let diagnostic = Diagnostic(
                node: node,
                message: PropertyMacroDiagnostic.invalidVectorDimensions
            )
            context.diagnose(diagnostic)
            return []
        }
        
        // Generate metadata comment for debugging
        return [
            """
            // MARK: - Vector Property Metadata
            // Generated by @Vector(dimensions: \(raw: dimensions)) macro
            // Property type: \(raw: typeString)
            // Kuzu type: DOUBLE[\(raw: dimensions)]
            // Note: Requires vector extension to be loaded
            """
        ]
    }
}

public struct FTSMacro: PeerMacro {
    public static func expansion(
        of node: AttributeSyntax,
        providingPeersOf declaration: some DeclSyntaxProtocol,
        in context: some MacroExpansionContext
    ) throws -> [DeclSyntax] {
        
        guard let variableDecl = declaration.as(VariableDeclSyntax.self) else {
            let diagnostic = Diagnostic(
                node: declaration,
                message: PropertyMacroDiagnostic.mustBeAppliedToProperty
            )
            context.diagnose(diagnostic)
            return []
        }
        
        // Validate String type
        guard let binding = variableDecl.bindings.first,
              let typeAnnotation = binding.typeAnnotation?.type else {
            return []
        }
        
        let typeString = typeAnnotation.description.trimmingCharacters(in: CharacterSet.whitespacesAndNewlines)
        let isStringType = typeString == "String" || typeString == "String?"
        
        if !isStringType {
            let diagnostic = Diagnostic(
                node: typeAnnotation,
                message: MacroExpansionErrorMessage("@FTS can only be applied to String properties")
            )
            context.diagnose(diagnostic)
            return []
        }
        
        // Generate metadata comment
        return [
            """
            // MARK: - FTS Property Metadata
            // Generated by @FTS macro for full-text search
            // Property type: \(raw: typeString)
            // Note: Requires FTS extension to be loaded
            // Usage: Can be queried with FTS functions like CONTAINS()
            """
        ]
    }
}

public struct TimestampMacro: PeerMacro {
    public static func expansion(
        of node: AttributeSyntax,
        providingPeersOf declaration: some DeclSyntaxProtocol,
        in context: some MacroExpansionContext
    ) throws -> [DeclSyntax] {
        
        guard declaration.is(VariableDeclSyntax.self) else {
            let diagnostic = Diagnostic(
                node: declaration,
                message: PropertyMacroDiagnostic.mustBeAppliedToProperty
            )
            context.diagnose(diagnostic)
            return []
        }
        
        // Generate metadata comment
        return [
            """
            // MARK: - Timestamp Property
            // Generated by @Timestamp macro
            // This property will be automatically updated with the current timestamp
            """
        ]
    }
}